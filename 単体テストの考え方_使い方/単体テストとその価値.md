## 良い単体テストとは
1.  テストすることが開発サイクルに組み込まれている
2. コードベースの特に重要な部分飲みがテスト対象となっている
3. 最小限の保守コストで最大限の価値を生み出すようになっている

### 良い単体テストを構成する4本柱
- 退行(Regression)に対する保護
- リファクタリングへの耐性
- 迅速なフィードバック
- テストの保守性

1. 退行(Regression)に対する保護
　　退行とは、バグのことである
   コードは資産ではなく、負債である
   そのため、退行に対して、どのくらいの保護テストが備わっているか把握するため
   以下のことに目を向けることが必要
   - テスト時に実行されるプロダクション・コードの量
   - そのコードの複雑さ
   - そのコードが扱っているドメインの重要性

   一般的にテストの際に実行されるプロダクションの、コード量が増えると退行がみつかる可能性が高まる
   さらに、コードの複雑さやドメインの重要性があります
   取るに足らないコードをテストしても、退行がみつかる可能性は低い
   さらに、退行が発生する子を回避するには、アプリケーションのために書かれたコードだけではなく、阿蘇のアプリケーションが使っているライブラリやフレームワークも含めてテストする必要がある
2. リファクタリングへの耐性

   このリファクタリングの耐性は、どのくらいプロダクションコードの変更をテストが失敗することなく行えるかを表す指標である
   意図通りの振る舞いをしているにも関わらず、テストが失敗することを偽陽性と呼び、これを避けた方が良い
   単体テストで重要なことは、新しい機能の追加やリファクタリングを退行なくできるようにすることである

   - 既存の機能に何らかの問題を持ち込んでしまった場合、テストによってそのことが早い段階で警告されるようになる
   　本番に流出する前に検知することができる
   - プロダクションコードを変更してお対抗がおこならないことに自信を持てるようになる
   　リファクタリングを躊躇わず行えるようになるため、コードの質が向上する
   しかし、偽陽性は、これらを無効化してしまう
   正当な理由もなくテストが失敗するようになると、テストが失敗することに慣れてしまって、テスト結果を重要視しなくなってしまう
   →ぶっちゃけ今はこの状態だと思われる

   何が偽陽性を引き起こすのか？
   プロダクションコードとテストコードが密接に結びついてしまうと、より多くの嘘の警告を引き起こす
   偽陽性を避けるための唯一の方法は、テストコードをプロダクションコードから分離することである
   実装の詳細ではなく、最終的な結果を確認する
   プロダクションコードをブラックボックスとして扱い、あくまでも、最終的な結果を確認する手順が正しであったりをみるのはだめ

   - 真陰性: 正しい
   - 偽陽性: 誤報
   - 真陽性: 正しい
   - 偽陰性: 誤報

   - 信号対ノイズ比: 
     テストの品質を表す指標
     テストの正確性= 信号(検出されたバグの数)/ノイズ(偽陽性の数)
     信号を増やすと、ノイズを減らすことで正確性が上がる
3. 迅速なフィードバック
   - テストの結果を速く得られる
4. テストの保守性

良いテストとは、上記の柱の掛け算である
理想的なテストは作成することができない、
退行の保護、リファクタリング耐性、迅疾なフィードバック
の3つの柱は、トレードオフの関係にある
テスト保守性は、独立している

リファクタリング耐性を犠牲にすることはできない
そのため、犠牲にするのは、
退行の保護と迅疾なフィードバック
となる

CAP定理が良い単体テストを構成する3つの柱に似ている

CAP定理とは、
C(Consistency) 一貫性: 全ての読み書きが同じ結果を返す
A(Availability): 可用性: 全ての読み書きが可能な状態
P(Partition tolerance): 分離耐性: ネットワークが分割されることを耐える
を指す定理である

### ブラックボックステストとホワイトボックステスト

ブラックボックステストとは、
プロダクションコードをブラックボックスとして扱い、
仕様書から作成される
リファクタリングへの耐性が高い
退行への耐性が低い

ホワイトボックステストとは、
プロダクションコードをホワイトボックスとして扱い、
ソースコードから作成される
リファクタリングへの耐性が低い
退行への耐性が高い

基本的には、ブラックボックスを採用するべき
ホワイトボックステストは、分析に用いる
カバレッジ計測でホワイトボックステストを利用して、検証
その後にそのことをあたかも知らない状態で、その検証結果を通るようなブラックボックスのテストを作成する
